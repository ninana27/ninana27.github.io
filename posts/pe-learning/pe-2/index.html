<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PE文件结构学习0x02 - 详解 DOS Stub | 27's blog</title>
<meta name=keywords content><meta name=description content="介绍
上一篇文章我们深入了解了DOS Header，其中我们谈到了它的一个重要作用 —— 向后兼容 MS-DOS 系统（在 MS-DOS 模式下运行时，会运行 DOS Stub 里的 DOS 程序）。那么 DOS Stub 是个怎样的 DOS 程序，这篇文章就让我们来一探究竟。
DOS Stub 概述
DOS Stub 紧跟在 DOS 头之后，位于 NT 头之前。DOS Stub 区域从偏移 0x40（DOS Header 结束处）开始，到 e_lfanew 指定位置（PE 头）之前的一段空间。在 DOS 环境下运行时，它会打印出 “This program cannot be run in DOS mode” 的错误消息。
在 PE-bear 查看这部分：

DOS 环境测试 PE
DOS 环境：DOSBox
在 DOS 环境运行测试程序：

在正常的CMD环境运行测试程序：

可以看到在 DOS 环境下打印了“This program cannot be run in DOS mode.”，DOS Stub
被执行了。"><meta name=author content="ninana27"><link rel=canonical href=https://ninana27.github.io/posts/pe-learning/pe-2/><link crossorigin=anonymous href=/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css integrity="sha256-bammPSWpYIvKL3+QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as=style><link rel=icon href=https://ninana27.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ninana27.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ninana27.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ninana27.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ninana27.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ninana27.github.io/posts/pe-learning/pe-2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://ninana27.github.io/posts/pe-learning/pe-2/"><meta property="og:site_name" content="27's blog"><meta property="og:title" content="PE文件结构学习0x02 - 详解 DOS Stub"><meta property="og:description" content="介绍 上一篇文章我们深入了解了DOS Header，其中我们谈到了它的一个重要作用 —— 向后兼容 MS-DOS 系统（在 MS-DOS 模式下运行时，会运行 DOS Stub 里的 DOS 程序）。那么 DOS Stub 是个怎样的 DOS 程序，这篇文章就让我们来一探究竟。
DOS Stub 概述 DOS Stub 紧跟在 DOS 头之后，位于 NT 头之前。DOS Stub 区域从偏移 0x40（DOS Header 结束处）开始，到 e_lfanew 指定位置（PE 头）之前的一段空间。在 DOS 环境下运行时，它会打印出 “This program cannot be run in DOS mode” 的错误消息。 在 PE-bear 查看这部分：
DOS 环境测试 PE DOS 环境：DOSBox
在 DOS 环境运行测试程序：
在正常的CMD环境运行测试程序：
可以看到在 DOS 环境下打印了“This program cannot be run in DOS mode.”，DOS Stub 被执行了。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-26T00:16:54-05:00"><meta property="article:modified_time" content="2025-04-26T00:16:54-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PE文件结构学习0x02 - 详解 DOS Stub"><meta name=twitter:description content="介绍
上一篇文章我们深入了解了DOS Header，其中我们谈到了它的一个重要作用 —— 向后兼容 MS-DOS 系统（在 MS-DOS 模式下运行时，会运行 DOS Stub 里的 DOS 程序）。那么 DOS Stub 是个怎样的 DOS 程序，这篇文章就让我们来一探究竟。
DOS Stub 概述
DOS Stub 紧跟在 DOS 头之后，位于 NT 头之前。DOS Stub 区域从偏移 0x40（DOS Header 结束处）开始，到 e_lfanew 指定位置（PE 头）之前的一段空间。在 DOS 环境下运行时，它会打印出 “This program cannot be run in DOS mode” 的错误消息。
在 PE-bear 查看这部分：

DOS 环境测试 PE
DOS 环境：DOSBox
在 DOS 环境运行测试程序：

在正常的CMD环境运行测试程序：

可以看到在 DOS 环境下打印了“This program cannot be run in DOS mode.”，DOS Stub
被执行了。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ninana27.github.io/posts/"},{"@type":"ListItem","position":2,"name":"PE文件结构学习0x02 - 详解 DOS Stub","item":"https://ninana27.github.io/posts/pe-learning/pe-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PE文件结构学习0x02 - 详解 DOS Stub","name":"PE文件结构学习0x02 - 详解 DOS Stub","description":"介绍 上一篇文章我们深入了解了DOS Header，其中我们谈到了它的一个重要作用 —— 向后兼容 MS-DOS 系统（在 MS-DOS 模式下运行时，会运行 DOS Stub 里的 DOS 程序）。那么 DOS Stub 是个怎样的 DOS 程序，这篇文章就让我们来一探究竟。\nDOS Stub 概述 DOS Stub 紧跟在 DOS 头之后，位于 NT 头之前。DOS Stub 区域从偏移 0x40（DOS Header 结束处）开始，到 e_lfanew 指定位置（PE 头）之前的一段空间。在 DOS 环境下运行时，它会打印出 “This program cannot be run in DOS mode” 的错误消息。 在 PE-bear 查看这部分：\nDOS 环境测试 PE DOS 环境：DOSBox\n在 DOS 环境运行测试程序：\n在正常的CMD环境运行测试程序：\n可以看到在 DOS 环境下打印了“This program cannot be run in DOS mode.”，DOS Stub 被执行了。\n","keywords":[],"articleBody":"介绍 上一篇文章我们深入了解了DOS Header，其中我们谈到了它的一个重要作用 —— 向后兼容 MS-DOS 系统（在 MS-DOS 模式下运行时，会运行 DOS Stub 里的 DOS 程序）。那么 DOS Stub 是个怎样的 DOS 程序，这篇文章就让我们来一探究竟。\nDOS Stub 概述 DOS Stub 紧跟在 DOS 头之后，位于 NT 头之前。DOS Stub 区域从偏移 0x40（DOS Header 结束处）开始，到 e_lfanew 指定位置（PE 头）之前的一段空间。在 DOS 环境下运行时，它会打印出 “This program cannot be run in DOS mode” 的错误消息。 在 PE-bear 查看这部分：\nDOS 环境测试 PE DOS 环境：DOSBox\n在 DOS 环境运行测试程序：\n在正常的CMD环境运行测试程序：\n可以看到在 DOS 环境下打印了“This program cannot be run in DOS mode.”，DOS Stub 被执行了。\nDOS Stub 代码分析 提取 DOS 程序 DOS Stub 本质上是一个简单的 16 位 DOS 程序，我们可以将 DOS Header （为了标识这是DOS 程序，确保能在 DOS 环境下运行） 和 DOS Stub 从 PE 中截取出来，单独作为一个 DOS 程序，方便我们后续的调试分析。这里我使用 winhex 将 DOS Header 和 DOS Stub 这两部分另存为一个名为 DOS-Stub.exe 的 DOS 程序：\n在 DOS 环境运行 DOS-Stub.exe： 成功运行。\n调试程序 开始调试程序（DOSBox + debug.exe）：\n查看汇编代码 查看当前寄存器 查看内存数据 逐步分析 接下我们将逐步调试分析这段汇编代码：\nPUSH CS ：这条指令把当前 CS（代码段寄存器）的值压入栈 在debug里用命令d ss:00B6查看栈，可以看到 0x076A 已被压入栈。\nPOP DS ：从栈里弹出刚才保存的 CS，赋值到 DS（数据段寄存器） 可以看到 DS 与 CS 值相同了，都是 0x076A，说明数据段（DS）和代码段（CS）指向同一个段地址。也就是说前面两步是一个整体，指明数据和代码在同一段上。\nMOVE DX,000Eh ：把 0x000E 这个偏移地址加载到 DX 寄存器 可以看到基地址加上这个偏移地址后是 “This program …” 的起始地址。\nMOVE AH,09h ：把 0x09 加载到 AH （ AX 寄存器的高8位） 可以看到 AX 寄存器的高8位，也就是前两位变为了 09 。\nINT 21h ：调用 DOS 系统中断 注意看，“This program cannot be run in DOS mode”竟然被神奇地打印出来了，并且INT 21 到下一步 MOVE AX,4C01h 之间还有其他代码 ，这是怎么做到的呢？为了搞明白这个问题，我们需要了解 DOS API 和 DOS INT 21h services 。维基百科上查看\n在 DOS 里，INT 21h 是一个软件中断。在调用INT 21h时，用 AH 寄存器传入子功能号，其他寄存器传入其他参数，从而调用主要的 DOS API（在DOS 内核中实现）提供的各种功能（比如：显示字符或字符串、键盘输入、退出程序等等）。\n再回到我们的代码，在调用 INT 21h 中断之前，MOVE AH,09h 设置 AH 为 09h ，09h 是显示字符串的功能号，它还有一个参数就是待显示字符串（必须以 $ 字符结束）地址，通过 DS:DX 传入。在设置 AH 之前 MOVE DX,000Eh 把字符串的内存偏移地址加载到 DX 寄存器里，DS:DX（ DS 先前已设置）组合形成完整的字符串地址（“This program …” 的起始地址），以备中断时调用。\nINT 21h 之后直到 MOVE AX,4C01h 之前的都是 DOS 内核的操作，就简单说下。\n在调用 INT 21h 时，会先保存当前状态，保存当前的CS和IP下一条指令的偏移地址到栈上： 接下来是 STI（开中断）这条指令是允许中断发生。然后就是中断服务程序的操作，大概操作是到 DS:DX 读取字符串循环输出每个字符，注意直到遇到 $ 结束，我们可以看到“This program cannot be run in DOS mode.”被显示。最后 IRET（中断返回） 这条指令是从中断服务程序返回到中断前保存的状态，也就是返回到MOVE AX,4C01h。\nMOVE AX,4C01h ：把 0x4C01 加载到 AX 寄存器 我们发现下一个指令是 INT 21h，也就是说这一步和上面的几步相似，是为调用 DOS 系统中断做准备，设置参数。 其实上 MOVE AX,4C01h 这一步的指令可以拆分成两步，把 AX 寄存器看成两个寄存器 AH（AH高8位）和 AL（AH低8位）MOVE AX,4C01h 就相当于：\nMOVE AH,4Ch：设置 AH 功能号4Ch，功能是终止程序并返退出码。按惯例，0 表示成功，非 0 表示错误。\nMOVE AL,01h：设置退出码01h（非 0）， 代表发生了某种错误。\nINT 21h ：调用 DOS 系统中断 最后可以看到程序正常终止退出。\n分析小结 这一部分我们逐步分析了 DOS Stub 的主要代码，明白了它是如何打印错误信息以及退出程序。\n思考 DOS Stub就这样分析完了吗？按照 DOS 程序来说的确是的。但是，我们发现 DOS 程序部分只占 DOS Stub 中的一部分： 剩下的部分是什么呢？\n答疑 按照 DOS Stub 与 PE 头之间剩余数据的说法，剩下的那部分就是随机填充的数据。\n但我们打开 PE-bear 查看时，发现了一个 PE 文件结构中从未谈及的一个部分，或者说是一个结构 —— Rich Header： Rich Header 介绍 Rich Header（也称为 Rich Signature 或 Rich Block）是 Windows 可执行文件 PE 文件中的一个隐藏数据结构，位于 DOS Stub 之后、PE Header 之前，由微软的编译器（如 MSVC）生成，记录了编译过程中使用的工具链（如编译器、链接器）的版本和构建信息。 了解更多有关 Rich header\nRich Header 结构 起始标记 DanS Signature (XOR 加密): DanS 通常是一个 4 字节的标记 0x536E6144，即 ASCII 字符串 “DanS”，经过 XOR 加密后的值。这是 Rich Header 结构化数据的实际开始。在 DanS 标记之前可能有一些填充字节，通常是 0x00 或 0xCC。\n在 DanS 标记之后，紧跟着三个 DWORD（共 12 字节）经过 XOR 加密的 0x00，\nCompID/Count 数据块 (XOR 加密): 这是 Rich Header 的核心部分，包含了一系列关于编译工具链的信息。这些信息由成对的 DWORD（每对共 8 字节）组成 (CompID, Count)。\nCompID (Component ID / Product ID): 通常是第一个 DWORD。它标识了具体的开发工具或组件及其版本。CompID 通常由两部分组成：\n高位字 (High Word, 2 字节): 产品 ID (ProdID)，标识工具类型。 低位字 (Low Word, 2 字节): 构建号 (BuildID)，标识工具的具体版本号。 Count: 通常是第二个 DWORD。它表示该特定工具在此次编译链接过程中被使用的次数。\nXOR 加密: 这个数据块整体使用一个 XOR 密钥进行了加密。密钥就是紧跟在 Rich 标记后面的那个 4 字节值（校验和）。\n结束标记 (Rich Signature): 一个 4 字节的标记 0x68636952，即 ASCII 字符串 “Rich”。这标志着 XOR 加密数据块的结束。\n校验和/XOR 密钥 (Checksum / XOR Key): 紧跟在 Rich 标记之后的一个 4 字节值。这个值既是整个 Rich Header的一个校验和，同时也用作解密 CompID/Count 数据块的 XOR 密钥。\nRich Header 分析 定位标记: 在 PE 文件中，先找到 PE 头 (PE\\0\\0) 的位置（由 DOS 头中的 e_lfanew 字段指定）。然后从此位置向前搜索 Rich 签名 (0x68636952)。\n提取密钥: 读取 Rich 签名紧随其后的 4 个字节，这就是 XOR 解密密钥（也是校验和）。\n定位数据: 从 Rich 签名位置继续向前搜索 DanS 签名 (0x536E6144)。DanS 签名之后（跳过 12 字节的填充 0x00）到 Rich 签名之前的部分就是加密的数据块。\n解密数据: 读取这个加密的数据块，将其中的每个 4 字节 (DWORD) 与之前提取的 XOR 密钥进行按位异或操作。\n解析数据: 将解密后的数据块视为连续的 (CompID, Count) 对。CompID 是第一个 DWORD，Count 是第二个 DWORD。\n这里为了练习就手动定位Rich Header，找到XOR 密钥，再写一个简单的解密程序：\n首先找到 PE 头签名，向前寻找到 RICH 签名 0x68636952，后面 4 字节 0x61D05846 就是 XOR 密钥。然后计算出加密后的 Dans = 0x536E6144 ^ 0x61D05846 = 0x32BE3902，再找到 0x32BE3902 从而确定整个加密数据。该数据在文件中的地址从 0x80 到 0xD7。\n单独将这块加密数据提取出来，开始解密：\n#include #include uint8_t rich_data[] = { 0x02,0x39,0xBE,0x32,0x46,0x58,0xD0,0x61,0x46,0x58,0xD0,0x61,0x46,0x58,0xD0,0x61, 0x4F,0x20,0x43,0x61,0x4A,0x58,0xD0,0x61,0x56,0xDC,0xD1,0x60,0x44,0x58,0xD0,0x61, 0x56,0xDC,0xD3,0x60,0x45,0x58,0xD0,0x61,0x56,0xDC,0xD4,0x60,0x4F,0x58,0xD0,0x61, 0x56,0xDC,0xD5,0x60,0x51,0x58,0xD0,0x61,0x1D,0x30,0xD1,0x60,0x4F,0x58,0xD0,0x61, 0x46,0x58,0xD1,0x61,0xE9,0x58,0xD0,0x61,0x46,0x58,0xD0,0x61,0x49,0x58,0xD0,0x61, 0x0D,0xDD,0xD2,0x60,0x47,0x58,0xD0,0x61, }; void decrypt_rich_header(const uint8_t *data, size_t size, uint32_t xor_key) { uint32_t dans = *(uint32_t *)data ^ xor_key; printf(\"Dans: 0x%08X\\n\", dans); for (size_t i = 1; i \u003c= 3; i += 1) { uint32_t padding = *(uint32_t *)(data + i * 4) ^ xor_key; printf(\"Padding%d: 0x%08X\\n\", i, padding); } for (size_t i = 16; i + 4 \u003c= size; i += 8) { uint32_t compid = *(uint32_t *)(data + i) ^ xor_key; uint32_t count = *(uint32_t *)(data + i + 4) ^ xor_key; printf(\"CompID: 0x%08X, Count: %u\\n\", compid, count); } } int main() { uint32_t xor_key = 0x61d05846; size_t size = sizeof(rich_data); decrypt_rich_header(rich_data, size, xor_key); return 0; } 解密结果： 对照 PE-bear 中的信息： 解密正确。\n最后是解析数据，我们可以查阅 BE-bear 官方解析文档，以确定具体的编译工具和版本。\n总结 这篇文章详细介绍了 DOS Stub ，并简单介绍了引申结构 Rich Header。虽然这部分在正常 PE 文件运行时几乎没什么作用，可有可无的，但是其中包含的信息分析起来还是非常有趣的。接下来就该进入到真正的 PE 文件结构的学习。\n","wordCount":"693","inLanguage":"en","datePublished":"2025-04-26T00:16:54-05:00","dateModified":"2025-04-26T00:16:54-05:00","author":{"@type":"Person","name":"ninana27"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ninana27.github.io/posts/pe-learning/pe-2/"},"publisher":{"@type":"Organization","name":"27's blog","logo":{"@type":"ImageObject","url":"https://ninana27.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ninana27.github.io/ accesskey=h title="27's blog (Alt + H)">27's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ninana27.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ninana27.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ninana27.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ninana27.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">PE文件结构学习0x02 - 详解 DOS Stub</h1><div class=post-meta><span title='2025-04-26 00:16:54 -0500 CDT'>April 26, 2025</span>&nbsp;·&nbsp;ninana27</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#dos-stub-概述>DOS Stub 概述</a></li><li><a href=#dos-环境测试-pe>DOS 环境测试 PE</a></li><li><a href=#dos-stub-代码分析>DOS Stub 代码分析</a><ul><li><a href=#提取-dos-程序>提取 DOS 程序</a></li><li><a href=#调试程序>调试程序</a></li><li><a href=#逐步分析>逐步分析</a></li><li><a href=#分析小结>分析小结</a></li></ul></li><li><a href=#思考>思考</a></li><li><a href=#答疑>答疑</a><ul><li><a href=#rich-header-介绍>Rich Header 介绍</a></li><li><a href=#rich-header-结构>Rich Header 结构</a></li><li><a href=#rich-header-分析>Rich Header 分析</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p>上一篇文章我们深入了解了DOS Header，其中我们谈到了它的一个重要作用 —— 向后兼容 MS-DOS 系统（在 MS-DOS 模式下运行时，会运行 DOS Stub 里的 DOS 程序）。那么 DOS Stub 是个怎样的 DOS 程序，这篇文章就让我们来一探究竟。</p><h2 id=dos-stub-概述>DOS Stub 概述<a hidden class=anchor aria-hidden=true href=#dos-stub-概述>#</a></h2><p><strong>DOS Stub</strong> 紧跟在 DOS 头之后，位于 NT 头之前。DOS Stub 区域从偏移 0x40（DOS Header 结束处）开始，到 <code>e_lfanew</code> 指定位置（PE 头）之前的一段空间。在 DOS 环境下运行时，它会打印出 “This program cannot be run in DOS mode” 的错误消息。
在 PE-bear 查看这部分：</p><p><img loading=lazy src=/images/pe-learning/pe-2-1.png></p><h2 id=dos-环境测试-pe>DOS 环境测试 PE<a hidden class=anchor aria-hidden=true href=#dos-环境测试-pe>#</a></h2><p>DOS 环境：<a href=https://www.dosbox.com/>DOSBox</a></p><p>在 DOS 环境运行测试程序：</p><p><img loading=lazy src=/images/pe-learning/pe-2-2.png></p><p>在正常的CMD环境运行测试程序：</p><p><img loading=lazy src=/images/pe-learning/pe-2-3.png></p><p>可以看到在 DOS 环境下打印了“This program cannot be run in DOS mode.”，DOS Stub
被执行了。</p><h2 id=dos-stub-代码分析>DOS Stub 代码分析<a hidden class=anchor aria-hidden=true href=#dos-stub-代码分析>#</a></h2><h3 id=提取-dos-程序>提取 DOS 程序<a hidden class=anchor aria-hidden=true href=#提取-dos-程序>#</a></h3><p>DOS Stub 本质上是一个简单的 16 位 DOS 程序，我们可以将 DOS Header （为了标识这是DOS 程序，确保能在 DOS 环境下运行） 和 DOS Stub 从 PE 中截取出来，单独作为一个 DOS 程序，方便我们后续的调试分析。这里我使用 <code>winhex</code> 将 DOS Header 和 DOS Stub 这两部分另存为一个名为 <code>DOS-Stub.exe</code> 的 DOS 程序：</p><p><img loading=lazy src=/images/pe-learning/pe-2-4.png>
<img loading=lazy src=/images/pe-learning/pe-2-5.png></p><p>在 DOS 环境运行 <code>DOS-Stub.exe</code>：
<img loading=lazy src=/images/pe-learning/pe-2-6.png></p><p>成功运行。</p><h3 id=调试程序>调试程序<a hidden class=anchor aria-hidden=true href=#调试程序>#</a></h3><p>开始调试程序（<code>DOSBox</code> + <code>debug.exe</code>）：</p><ul><li><p>查看汇编代码
<img loading=lazy src=/images/pe-learning/pe-2-7.png></p></li><li><p>查看当前寄存器
<img loading=lazy src=/images/pe-learning/pe-2-8.png></p></li><li><p>查看内存数据
<img loading=lazy src=/images/pe-learning/pe-2-9.png></p></li></ul><h3 id=逐步分析>逐步分析<a hidden class=anchor aria-hidden=true href=#逐步分析>#</a></h3><p>接下我们将逐步调试分析这段汇编代码：</p><ol><li><code>PUSH CS</code> ：这条指令把当前 CS（代码段寄存器）的值压入栈
<img loading=lazy src=/images/pe-learning/pe-2-10.png></li></ol><p>在debug里用命令<code>d ss:00B6</code>查看栈，可以看到 <code>0x076A</code> 已被压入栈。</p><ol start=2><li><code>POP DS</code> ：从栈里弹出刚才保存的 CS，赋值到 DS（数据段寄存器）
<img loading=lazy src=/images/pe-learning/pe-2-11.png></li></ol><p>可以看到 DS 与 CS 值相同了，都是 <code>0x076A</code>，说明数据段（DS）和代码段（CS）指向同一个段地址。也就是说前面两步是一个整体，指明数据和代码在同一段上。</p><ol start=3><li><code>MOVE DX,000Eh</code> ：把 0x000E 这个偏移地址加载到 DX 寄存器
<img loading=lazy src=/images/pe-learning/pe-2-12.png></li></ol><p>可以看到基地址加上这个偏移地址后是 “This program &mldr;” 的起始地址。</p><ol start=4><li><code>MOVE AH,09h</code> ：把 0x09 加载到 AH （ AX 寄存器的高8位）
<img loading=lazy src=/images/pe-learning/pe-2-13.png></li></ol><p>可以看到 AX 寄存器的高8位，也就是前两位变为了 <code>09</code> 。</p><ol start=5><li><code>INT 21h</code> ：调用 DOS 系统中断
<img loading=lazy src=/images/pe-learning/pe-2-14.png></li></ol><p>注意看，“This program cannot be run in DOS mode”竟然被神奇地打印出来了，并且<code>INT 21</code> 到下一步 <code>MOVE AX,4C01h</code> 之间还有其他代码 ，这是怎么做到的呢？为了搞明白这个问题，我们需要了解 <strong>DOS API</strong> 和 <strong>DOS INT 21h services</strong> 。<a href=https://en.wikipedia.org/wiki/DOS_API#DOS_INT_21h_services>维基百科上查看</a></p><p>在 DOS 里，INT 21h 是一个软件中断。在调用INT 21h时，用 AH 寄存器传入子功能号，其他寄存器传入其他参数，从而调用主要的 DOS API（在DOS 内核中实现）提供的各种功能（比如：显示字符或字符串、键盘输入、退出程序等等）。</p><p>再回到我们的代码，在调用 INT 21h 中断之前，<code>MOVE AH,09h</code> 设置 AH 为 <code>09h</code> ，<code>09h</code> 是显示字符串的功能号，它还有一个参数就是待显示字符串（必须以 <code>$</code> 字符结束）地址，通过 DS:DX 传入。在设置 AH 之前 <code>MOVE DX,000Eh</code> 把字符串的内存偏移地址加载到 DX 寄存器里，DS:DX（ DS 先前已设置）组合形成完整的字符串地址（“This program &mldr;” 的起始地址），以备中断时调用。</p><p><code>INT 21h</code> 之后直到 <code>MOVE AX,4C01h</code> 之前的都是 DOS 内核的操作，就简单说下。</p><p>在调用 <code>INT 21h</code> 时，会先保存当前状态，保存当前的<code>CS</code>和<code>IP</code>下一条指令的偏移地址到栈上：
<img loading=lazy src=/images/pe-learning/pe-2-16.png></p><p>接下来是 <code>STI</code>（开中断）这条指令是允许中断发生。然后就是中断服务程序的操作，大概操作是到 <code>DS:DX</code> 读取字符串循环输出每个字符，注意直到遇到 <code>$</code> 结束，我们可以看到“This program cannot be run in DOS mode.”被显示。最后 <code>IRET</code>（中断返回） 这条指令是从中断服务程序返回到中断前保存的状态，也就是返回到<code>MOVE AX,4C01h</code>。</p><ol start=6><li><code>MOVE AX,4C01h</code> ：把 0x4C01 加载到 AX 寄存器
<img loading=lazy src=/images/pe-learning/pe-2-15.png></li></ol><p>我们发现下一个指令是 <code>INT 21h</code>，也就是说这一步和上面的几步相似，是为调用 DOS 系统中断做准备，设置参数。
其实上 <code>MOVE AX,4C01h</code> 这一步的指令可以拆分成两步，把 AX 寄存器看成两个寄存器 AH（AH高8位）和 AL（AH低8位）<code>MOVE AX,4C01h</code> 就相当于：</p><p><code>MOVE AH,4Ch</code>：设置 AH 功能号4Ch，功能是终止程序并返退出码。按惯例，0 表示成功，非 0 表示错误。</p><p><code>MOVE AL,01h</code>：设置退出码01h（非 0）， 代表发生了某种错误。</p><ol start=7><li><code>INT 21h</code> ：调用 DOS 系统中断
<img loading=lazy src=/images/pe-learning/pe-2-17.png></li></ol><p>最后可以看到程序正常终止退出。</p><h3 id=分析小结>分析小结<a hidden class=anchor aria-hidden=true href=#分析小结>#</a></h3><p>这一部分我们逐步分析了 DOS Stub 的主要代码，明白了它是如何打印错误信息以及退出程序。</p><h2 id=思考>思考<a hidden class=anchor aria-hidden=true href=#思考>#</a></h2><p>DOS Stub就这样分析完了吗？按照 DOS 程序来说的确是的。但是，我们发现 DOS 程序部分只占 DOS Stub 中的一部分：
<img loading=lazy src=/images/pe-learning/pe-2-18.png></p><p>剩下的部分是什么呢？</p><h2 id=答疑>答疑<a hidden class=anchor aria-hidden=true href=#答疑>#</a></h2><p>按照 DOS Stub 与 PE 头之间剩余数据的说法，剩下的那部分就是随机填充的数据。</p><p>但我们打开 PE-bear 查看时，发现了一个 PE 文件结构中从未谈及的一个部分，或者说是一个结构 —— <strong>Rich Header</strong>：
<img loading=lazy src=/images/pe-learning/pe-2-19.png></p><h3 id=rich-header-介绍>Rich Header 介绍<a hidden class=anchor aria-hidden=true href=#rich-header-介绍>#</a></h3><p>Rich Header（也称为 Rich Signature 或 Rich Block）是 Windows 可执行文件 PE 文件中的一个隐藏数据结构，位于 DOS Stub 之后、PE Header 之前，由微软的编译器（如 MSVC）生成，记录了编译过程中使用的工具链（如编译器、链接器）的版本和构建信息。
<a href=https://www.ntcore.com/files/richsign.htm>了解更多有关 Rich header</a></p><h3 id=rich-header-结构>Rich Header 结构<a hidden class=anchor aria-hidden=true href=#rich-header-结构>#</a></h3><ol><li>起始标记 DanS Signature (XOR 加密):</li></ol><p>DanS 通常是一个 4 字节的标记 0x536E6144，即 ASCII 字符串 &ldquo;DanS&rdquo;，经过 XOR 加密后的值。这是 Rich Header 结构化数据的实际开始。在 DanS 标记之前可能有一些填充字节，通常是 0x00 或 0xCC。</p><p>在 DanS 标记之后，紧跟着三个 DWORD（共 12 字节）经过 XOR 加密的 0x00，</p><ol start=2><li>CompID/Count 数据块 (XOR 加密):</li></ol><p>这是 Rich Header 的核心部分，包含了一系列关于编译工具链的信息。这些信息由成对的 DWORD（每对共 8 字节）组成 (CompID, Count)。</p><p>CompID (Component ID / Product ID): 通常是第一个 DWORD。它标识了具体的开发工具或组件及其版本。CompID 通常由两部分组成：</p><ul><li>高位字 (High Word, 2 字节): 产品 ID (ProdID)，标识工具类型。</li><li>低位字 (Low Word, 2 字节): 构建号 (BuildID)，标识工具的具体版本号。</li></ul><p>Count: 通常是第二个 DWORD。它表示该特定工具在此次编译链接过程中被使用的次数。</p><p>XOR 加密: 这个数据块整体使用一个 XOR 密钥进行了加密。密钥就是紧跟在 Rich 标记后面的那个 4 字节值（校验和）。</p><ol start=3><li><p>结束标记 (Rich Signature):
一个 4 字节的标记 0x68636952，即 ASCII 字符串 &ldquo;Rich&rdquo;。这标志着 XOR 加密数据块的结束。</p></li><li><p>校验和/XOR 密钥 (Checksum / XOR Key):
紧跟在 Rich 标记之后的一个 4 字节值。这个值既是整个 Rich Header的一个校验和，同时也用作解密 CompID/Count 数据块的 XOR 密钥。</p></li></ol><h3 id=rich-header-分析>Rich Header 分析<a hidden class=anchor aria-hidden=true href=#rich-header-分析>#</a></h3><ol><li><p>定位标记: 在 PE 文件中，先找到 PE 头 (PE\0\0) 的位置（由 DOS 头中的 e_lfanew 字段指定）。然后从此位置向前搜索 Rich 签名 (0x68636952)。</p></li><li><p>提取密钥: 读取 Rich 签名紧随其后的 4 个字节，这就是 XOR 解密密钥（也是校验和）。</p></li><li><p>定位数据: 从 Rich 签名位置继续向前搜索 DanS 签名 (0x536E6144)。DanS 签名之后（跳过 12 字节的填充 0x00）到 Rich 签名之前的部分就是加密的数据块。</p></li><li><p>解密数据: 读取这个加密的数据块，将其中的每个 4 字节 (DWORD) 与之前提取的 XOR 密钥进行按位异或操作。</p></li><li><p>解析数据: 将解密后的数据块视为连续的 (CompID, Count) 对。CompID 是第一个 DWORD，Count 是第二个 DWORD。</p></li></ol><p>这里为了练习就手动定位Rich Header，找到XOR 密钥，再写一个简单的解密程序：</p><p><img loading=lazy src=/images/pe-learning/pe-2-20.png></p><p>首先找到 PE 头签名，向前寻找到 RICH 签名 <code>0x68636952</code>，后面 4 字节 <code>0x61D05846</code> 就是 XOR 密钥。然后计算出加密后的 Dans = <code>0x536E6144</code> ^ <code>0x61D05846</code> = <code>0x32BE3902</code>，再找到 <code>0x32BE3902</code> 从而确定整个加密数据。该数据在文件中的地址从 <code>0x80</code> 到 <code>0xD7</code>。</p><p>单独将这块加密数据提取出来，开始解密：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>rich_data</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x02</span><span class=p>,</span><span class=mh>0x39</span><span class=p>,</span><span class=mh>0xBE</span><span class=p>,</span><span class=mh>0x32</span><span class=p>,</span><span class=mh>0x46</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x46</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x46</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x4F</span><span class=p>,</span><span class=mh>0x20</span><span class=p>,</span><span class=mh>0x43</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x4A</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x56</span><span class=p>,</span><span class=mh>0xDC</span><span class=p>,</span><span class=mh>0xD1</span><span class=p>,</span><span class=mh>0x60</span><span class=p>,</span><span class=mh>0x44</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x56</span><span class=p>,</span><span class=mh>0xDC</span><span class=p>,</span><span class=mh>0xD3</span><span class=p>,</span><span class=mh>0x60</span><span class=p>,</span><span class=mh>0x45</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x56</span><span class=p>,</span><span class=mh>0xDC</span><span class=p>,</span><span class=mh>0xD4</span><span class=p>,</span><span class=mh>0x60</span><span class=p>,</span><span class=mh>0x4F</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x56</span><span class=p>,</span><span class=mh>0xDC</span><span class=p>,</span><span class=mh>0xD5</span><span class=p>,</span><span class=mh>0x60</span><span class=p>,</span><span class=mh>0x51</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x1D</span><span class=p>,</span><span class=mh>0x30</span><span class=p>,</span><span class=mh>0xD1</span><span class=p>,</span><span class=mh>0x60</span><span class=p>,</span><span class=mh>0x4F</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x46</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD1</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0xE9</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x46</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span><span class=mh>0x49</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x0D</span><span class=p>,</span><span class=mh>0xDD</span><span class=p>,</span><span class=mh>0xD2</span><span class=p>,</span><span class=mh>0x60</span><span class=p>,</span><span class=mh>0x47</span><span class=p>,</span><span class=mh>0x58</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span><span class=mh>0x61</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>decrypt_rich_header</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>xor_key</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>dans</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)</span><span class=n>data</span> <span class=o>^</span> <span class=n>xor_key</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Dans: 0x%08X</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dans</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>padding</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>4</span><span class=p>)</span> <span class=o>^</span> <span class=n>xor_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Padding%d: 0x%08X</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>padding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>&lt;=</span> <span class=n>size</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>compid</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>^</span> <span class=n>xor_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>count</span>  <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span> <span class=o>^</span> <span class=n>xor_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;CompID: 0x%08X, Count: %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>compid</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>xor_key</span> <span class=o>=</span> <span class=mh>0x61d05846</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rich_data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>decrypt_rich_header</span><span class=p>(</span><span class=n>rich_data</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>xor_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>解密结果：
<img loading=lazy src=/images/pe-learning/pe-2-21.png></p><p>对照 PE-bear 中的信息：
<img loading=lazy src=/images/pe-learning/pe-2-22.png></p><p>解密正确。</p><p>最后是解析数据，我们可以查阅 <a href=https://github.com/hasherezade/bearparser/blob/master/parser/pe/RichHdrWrapper.cpp>BE-bear 官方解析文档</a>，以确定具体的编译工具和版本。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>这篇文章详细介绍了 DOS Stub ，并简单介绍了引申结构 Rich Header。虽然这部分在正常 PE 文件运行时几乎没什么作用，可有可无的，但是其中包含的信息分析起来还是非常有趣的。接下来就该进入到真正的 PE 文件结构的学习。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://ninana27.github.io/posts/pe-learning/pe-1/><span class=title>Next »</span><br><span>PE文件结构学习0x01 - 深入DOS Header并将其打印</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ninana27.github.io/>27's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>